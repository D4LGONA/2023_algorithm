list comprehension 남은 것
-> 편한 방법으로 리스트를 선언하는 방법들.
랜덤한 값으로 배열 채우기
ord() -> 아스키코드 넘겨주는 함수 chr() 다시 문자열로 바꾸는 것 같은뎅
[[[] for _ in range(3)] for _ in range(4)] 오 쩌는데
클래스 안에 __repr__(self): -> 이 객체가 문자열로 표현되어야 할때 호출됨
map(클래스, collection) 이렇게 맵을 만들 수 있다네요
그 클래스의 객체들이 담긴 맵이 될 거에요

-- chapter 6 -- 정렬 알고리즘 
: 각 정렬의 장단점 ..
느린 녀석들은 구현이 쉽고 빠른 녀석들은 구현이 어려움
시간/공간 복잡도 외워야 함? ㅠㅠ
 -> stable은 같은거 두개가 있을때 자리를 바꾸나? 안바뀌는게 안정적인거래요
nlogn보다 빠를 수 없음(입력이 제한되는애들은 빠를수 있긴함)

-내부 정렬 : 입력의 크기가 주기억장치의 공간보다 크지 않은 경우(대부분의 우리가 아는 정렬)
-외부 정렬 :  '' 큰경우

1. 버블 정렬
 : 이웃하는 숫자를 비교하여 작은 수를 앞쪽으로 이동시키는 과정을 반복하여 정렬
작은 수는 앞으로 이동하고 큰 수는 뒤로 가는게 거품같아서 버블이라네요...
정말 오래 걸려요! O(n^2) -> n(n-1)/2 * O(n) = O(n^2) * O(1) = O(n^2)
움직이는애를 주인공이라고 할 거에요(여기선 제일 큰 값이죠) 주인공이 바껴서 느리대요
pass: 입력을 전반적으로 1번 처리하는것, 한번 pass동안 한개의 값이 정렬 완료됨!!
개선이 되긴 함 어디까지 정렬됐는지 기억하는 방식으로... 최선 O(n)

2. 선택 정렬
 : 제일 작은 수를 찾아서 맨 왼쪽으로 보낸다(큰수를 오른쪽으로 보내는것도 상관x)
최솟값의 위치를 기억하고 있기로 합니다. 
n(n-1) / 2 * O(1) = O(n^2) : O(1) -> 참일때 자리바꾸는것
항상 일정한 시간 복잡도, 입력에 민감하지 않은 알고리즘, 원소 간의 자리바꿈 횟수가 최소
평균적으로 버블 정렬보다 빠름
실전에 사용되지 않음
랜덤자료는 선택정렬이 셋중에젤빠르지만 더 빨라지지 않아서 사용하지 않음
거의 정렬된 녀석을 정렬해도 빨라지지 않음ㅠㅠ 삽입정렬과 버블정렬은 빨라짐

3. 삽입 정렬
 : 정렬된 부분과 정렬 안된부분으로 나누고, 정렬 안 된 부분의 가장 왼쪽 원소를 정렬된 부분의 적절한 위치에 삽입하여 정렬되도록 하는 과정을 반복
1번 인덱스부터 시작함
버블정렬과 다르게 하나의 pass 안에서 주인공이 바뀌지 않음
-> 교환을 하지 않고 주인공을 다른데 갖다놓은뒤 큰 애들을 뒤로 쭉쭉 밀고 들어갈데에 주인공 놓기
이게 삽입정렬의 성능 개선 요인입니다
선택정렬보다 느림. 최소한의 교환, 랜덤하게 섞어서
실전에서도 사용되는 녀석이에요
최악의 경우 O(n^2) 오 만약 최대 3개 가면(거의 정렬된 녀석) O(n)에 가까워져요(최선 O(n))
거의 정렬된 입력에 대해 빠름. 입력의 크기가 작을때 좋은 성능
퀵 정렬, 합병 정렬에서 입력 크기가 작아지면 순환 호출을 중단하고 삽입정렬을 사용
tim sort에서 크기가 64 이하면 삽입정렬을 호출
파이썬에서 tim sort를 사용하는 이유: 안정성 때문(퀵소트는 안정적이지 않음)

최선에 가깝게 만들 수 있으면 최선의 시간복잡도를 생각해도 됨
평균은 중요하지 않다네요?

4. 쉘 정렬(사람 이름ㅋㅋ)
 : gap을 이용 -> 정렬하는 자리바꾸기 할때 한번에 갭 만큼 움직일 수 있다는 장점이...
멀리 가는 애들을 빠르게 보낼 수 있음 갭이 줄어들었을때는 거의 정렬된 상태가 되는거죠
주인공을 gap부터 뒤로 쭉쭉 해서 정렬해요
gap을 큰거부터 차례대로 줄여가고, 마지막에는 반드시 1로 해야 함
gap이 1이면 그냥 삽입 정렬임
간격에 따라 시간복잡도가 달라짐. 아직 풀리지 않았어요(3등분 되게 갭을 만든다는것 같네요)
가장 좋은 간격을 아직 알지 못해서 ..
최악 O(n^1.5) 라네요 nlogn보다 느림 일단 위에 세개보단 훨씬 빠름
갭을 어떻게 설정하느냐에 따라 성능이 많이 달라진다네요





