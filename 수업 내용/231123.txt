chapter 8 근사 알고리즘

np 완전 문제를 해결하려면 3가지중 하나를 포기해야 함
1. 다항식 시간에 해를 찾는것 (오래걸리면 의미가 없음)
2. 모든 입력에 대해 해를 찾는것
3. 최적해를 찾는것

근사 알고리즘: 최적해는 찾지 못하지만(근사해 만을 찾음) 다항식 시간이 걸리는 알고리즘.
근사 알고리즘은 알고리즘과 함께 근사비율을 제시해야 함.
근사비율: 근사해의 값과 최적해의 값의 비율, 1.0에 가까울수록 정확도가 높은 것
하지만 근사비율을 구하려면 최적해를 알아야하는 모순이 생겨, 이를 대신하기 위해 간접적인 최적해를 찾고 이를 최적해로 칭함

8.1 여행자 문제: 임의의 한 도시에서 출발해 다른 모든 도시를 1번씩만 방문하고 다시 출발했던 도시로 돌아오는 최소 경로.
MST를 사용하기 위한 가정
 - A->B는 B->A랑 같다
 - A->B는 A->C->B보다 항상 빠르다
MST를 활용해 근사해를 찾기 위해서 삼각 부등식 원리를 이용
시간복잡도
크러스컬 O(mlogm)(m은 간선수), 프림 O(nlogn)(n은 정점수) -> MST를 구하는 알고리즘의 시간복잡도를 따라감
최적해는 MST보다 반드시 크고 근사해는 2 * MST보다 반드시 작음. 따라서 근사비율은 2.0보다 무조건 작음
시작점에 따라 다른 근사해가 나올 것

정점 커버
1. set cover 사용
근사비율 k ln n -> 2.0을 넘어갈 가능성이 있음
2. 극대 매칭 이용
매칭은 두개씩 짝지어 주는 것. 간선의 양 끝점이 이미 커버된 간선의 끝점이 아닐 때에만 선택
얘가 위에 녀석보다 근사비율이 더 좋다네요 무조건 2.0보다 작음. 시간복잡도는 O(n) x m = O(nm) (m은 간선수)

통에 물건 넣는 거: 통을 최소로..
그리디 아이디어
1. 최초 적합: 처음부터 봐서 여유 있는 녀석 O(n^2) 중 빠름
2. 다음 적합: 직전에 넣은 녀석에 여유가 있으면 또 넣기 O(n)
3. 최선 적합: 기존 통중 새걸 넣으면 가장 적게 남는 통에 넣기 O(n^2)
4. 최악 적합: 기존 통중 새걸 넣으면 가장 많이 남는 통에 넣기 O(n^2)
최초/최선/최악 적합은 절반 이하 채워진 통이 2개 이상일 수 없음. 근사비율은 2.0 이하
다음 적합은 이웃한 두 통의 합이 10보다 작을 수 없음. 따라서 근사비율은 2.0 이하
근사비율은 '아무리 많이 늘어나도' 2.0이라는 것임

작업 스케줄링: ti시간이 걸리는 n개의 작업을 m개의 기계에 빨리 끝나도록 배정하는 것
기말고사에는 현재 상태를 보여주고 어떻게 배정될 것이냐를 물어볼 거에요
시간복잡두 O(nm)
근사비율 과정은 패스.. 근사비율은 2.0

클러스터링 문제: 면적으로 균등하게 잘 나눴는가..
첫번째 센터는 아무거나 정하고 두번째 센터는 얘랑 가장 먼 것, 세번째 센터는 그 둘과 가장 먼 것, ...
가장 가까운 센터와의 거리만 가지고 있음
점들을 모두 포함한 가장 작은 원 구하는 뭐시기 저시기 알고리즘
시간복잡도 O((k^2)n)
근사비율 과정 패스... 2.0
첫번째를 랜덤으로 정하는게 별로여서 여러번 실행 함 가장 괜찮은 녀석으로 채택









