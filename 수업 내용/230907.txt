# 1-2 순차탐색(앞에서부터 하나하나 천천히 찾아가는 것)
한번 검색마다 1개가 탈락.

# 1-3 이진탐색(정렬 돼 있을 때만 사용 가능, 가운데랑 비교하는 것)
한번 검색마다 1/2개가 탈락.
코드에서 두 개(left, right)가 역전되면 프로그램이 종료되도록 되어 있어요
남은게 두 개정도면 그냥 순차탐색 돌리도록 짜는것도 좋아요

# 1-4-1 5글자짜리만 배열에 담아 출력하는 프로그램이에요
왜 했냐?  1-4-2를 위해서

# 1-4-2 앞에서 만든 배열을 가져와서 대문자로 바꾸고 랜덤 숫자를 줘서
city 객체를 만드는 프로그램이에요

# 1-4-3 몇개의 city만 따서 랜덤 좌표로 화면에 표시할 거에요
인접점 표기 방식 : 0번과 1, 9가 이어져 있고, 1번과 0, 2가 이어져 있고... 이런 코드에요
한붓그리기의 점을 어떻게 선택할 것이냐? : 사이클이 있는 쪽으로 갈 거에요
0번에선 두 개 갈 수 있어요 0에서 1로 간다 가정합니다
사이클은 간선을 지워서 확인해요 0과 1을 이은 간선을 임시로 지우고
다른 방법으로 0에서 1로 갈 수 있는지 확인해요(마킹하고 이동하고..)
가능하기 때문에 0-1 간선을 삭제합니다. 이제 1로 넘어 왔어요
이 작업을 계속 반복합니다.
사이클을 확인할 때 만약 이미 마킹되어있다면 뒤로 돌아와요
: 갈림길이 하나밖에 없다면 그 길로 가고, 여러 개라면 사이클이 있는 곳으로 가요

# chapter 2.

알고리즘이란 ?
특성 : 정확성(올바른 해), 수행성(컴퓨터에서 수행), 유한성(무한루프 x), 효율성(효율적이어야)
(bogo sort: 랜덤하게 뽑아서 바꿔 정렬되길 비는 거에요. 유한성 x)
최초의 알고리즘: 유클리드의 최대공약수 알고리즘
뺄셈 말고 나머지 연산을 이용하면 빠르다네요...
pseudo code
알고리즘의 표현 방법 : 단계별 절차, pseudo code(의사 코드)로 표현하는게 좋아요
왜 알고리즘을 기술하는가 : 다른 사람한테 내가 생각한 걸 시키려고!
pseudo code를 쓰면 빨리 쓰고 빨리 읽을 수 있어요
빨리 쓸 수 있고 읽을 수 있도록 써야 해요
자연어, 프로그래밍 언어, pseudo code, 플로우 차트 이렇게 네 가지 방법이 있어요
플로우 차트는 외주 받은 회사가 이렇게 만들게요 하고 보여주는데 좋대요(보고서?)

알고리즘의 분류 ... 우리는 정렬 알고리즘을 살펴볼 거에요
- 분할정복
- 그리디
- 동적계획
- 근사
- 백트래킹
- 분기 한정

** 효율성 ** : 영희와 철수의 가짜 동전 찾기...
 : 수행시간 또는 사용되는 메모리 크기로 나타냄.
   시간 복잡도, 공간 복잡도(, 개발 복잡도?..) -> 수식으로 표현하는 것
   시간 복잡도를 주로 사용해요

시간 복잡도 : 알고리즘이 실핻외는 동안 사용된 기본 연산(데이터간 크기 비교 등..) 횟수
 -> 최악, 평균, 최선의 경우 분석(일반적으로 최악으로 수행시간을 표현)
상각 분석? 총 수행시간을 합해 연산 횟수로 나눔?
등교 시간 분석 ? ㅋㅋ
kruskal의 최소신장(늘어난다는뜻; spanning의 번역이라네요)트리 알고리즘?

복잡도의 점근적 표기 : 시간복잡도를 표현하는 방법
big-oh, big-omega, theta 표기...가 있대요

Big-Oh(점근적 상한) : 아이쿠 모르겠당 무슨 상수를 곱해서 선보다 위로 어쩌구...
Big-Omega(점근적 하한) : 얘는 아래로 어쩌구..
둘다 만족하는 애가 theta(동일한 증가율)라는데요? 전혀 모르겠음 오잉 수식을 찾으라고요?
간단한 방법: 다항식에서 최고 차수 항 만을 취한 뒤, 그 항의 계수를 제거하면 g(n)이 된다
와 전혀 이해가 안가 예시를 보여 주셨는데
더 높은 차수랑 비교하는게 의미 없다는 것 같은데요?
앞으로 모든 알고리즘의 성능은 theta로 얘기하는데 그냥 O()로 쓴대요
n^2짜리 알고리즘 까지만 사용합니다.
갑자기 딕셔너리랑 해시로 넘어갔네요
n! > 2^n > n^2 > nlogn > n > logn 

10억개를 정렬하면 O(n^2) 300년, O(nlogn) 5분 걸린다네요
효율적인 알고리즘을 짜는게 중요해요

요약 ... ...




