tuple.py: comma로 연결하면 튜플이 된다, 튜플을 대입할 수 있다
tuple는 write가 안됨.

function: 
1) 인수분해: 비슷한 일을 할때 공통적인것은 함수로 정의, 달라지는것은 인자로 전달.
2) 동작의 추상화: 함수 이름을 잘 정해 놓으면 함수 이름만 보고도 무슨 코드인지 알 수 있을 것
한번 정의해 놓고 여러번 호출하기 위해서도 사용
함수 안에서 write를 먼저 하면 지역변수
함수 안에서 read를 먼저 하면 전역변수
read를 먼저하고 write를 나중에 하면 충돌한다는데요ㅠㅠ?
global로 선언해야한다는데요? 외부에서 정의한 변수를 읽고 쓰려면 global을 써야 해요
인자를 전달하기. func(x,y)로 선언하면 두개 받아야하는데 튜플 하나 주면 못알아듣는대요 근데 튜플앞에 *붙이면 튜플이 펼쳐진대요 리스트도 그렇고
	          -> 원소 개수가 2개여야 해요 여기서는.. 개수가 안맞으면 에러 난대요
오잉 func(y=10,x=100)이렇게 호출할 수도 있다네요
default argument는 c/c++이랑 똑같네요 None을 쓰고 밑에서 default를 처리하는 방법도 있군
딕셔너리로 넘기는 방법도 있군 근데 **딕셔너리 이렇게 해야 한다는데요
가변인자...? 함수.....? 개수상관없이 넘겨받고 리스트로 받는거래요 함수 정의할때 func(*x) 이런식으로 써요
딕셔너리로 받는 녀석은 func(**x)요렇게 선언해요
튜플로 리턴해서 함수에서 2개 이상의 값을 리턴하기ㅋㅋ 하지만 튜플로 리턴되죠 그게 하나... 이긴 하죠

class Hello:
    pass -> 줄 비워두면 안돼서 pass를 쓰는 것(끝나는 부분을 알려주기 위해)
함수호출과 객체생성의 문법이 같습니다(c++에서는 new를 쓰죠...) ex) h = Hello()
변수에 냅다 클래스 담았다가 함수 담았다가 그러는데요ㅠㅠ?
객체를 생성하고 나서 클래스에 멤버변수를 새로 만들어줄 수 있어요
hasatter()을 이용해서 속성을 확인할수있음. 클래스자체에 생기는게 아니라 각 객체에만 생기는 듯요
func __init__(self): 생성자, 여기서 self.xxx로 멤버변수를 줄 수있음 생성자는 자동 호출이네요
생성자에 인자 갈기기ㅋㅋ def __init__(self, name='Unknown', age=0)
hw1.print() == Helloworld.print(hw1)
상속 없이도 다형성 구현이 가능하다 ?? 각각 다른 클래스여도 이름 같은 함수가 있으면 각자 자기 함수를 호출한대요 신기하다 없으면 에러 남
상속 어떻게 하냐 class X(부모클래스): 이렇게 해요 샹성자는 똑같이 받아서 super().__init__에 넘겨준다는데요ㅠㅠ?
오버라이딩 어쩌구... 재정의 안하면 부모클래스의 함수를 호출한다네요

text_format: 텍스트 포매팅
% 연산자를 이용해 c 스타일의 텍스트 포매팅을 할 수 잇아요
format()으로도 가능, 넘긴 애들이 {} 있는 자리에 하나씩 들어간대요
>는 오른쪽정렬, <는 왼쪽정렬, ^는 가운데 정렬 어쩌구...
f-string -> print(f'{x:^15}') 이런식으로 쓴다는데 무슨 말인지 모르겠어요 코드를 보도록 해요
그외에도 기타등등있어요

module: 하나의 파일이 하나의 모듈이라고 생각합니다. 지금 실행하고 있는 파일이 메인 모듈이 돼요. import를 이용해서 모듈을 불러옵니다
예시로 math의 math.sqrt를 보여주셨어요 import math as m으로 불러오면 m.sqrt 이렇게 쓸 수도 잇어요
from math import * 이렇게하면 그냥 쓸 수 잇어요
atan2(y, x) 이거 쓰래요 단위는 무조건 radian
pygame 실행끝나면 바로 꺼져서 무한루프 돌려놓고 메시지 처리해요 윈플마냥.. 
피코투디 좌하단이 원점 터틀은 가운데 좌표계변환을 해야 하는군
점찍기 선그리기 뭐 이런거 하고 익군요

list_comprehension: f-string에 이름찍고 값 찍는 방법이 있군요
x = [i ** 2 for i in range(10)] 얘가 리스트 컴프리헨션인데 이렇게하면 x = [0,4,9,16,...] 이렇게 됨 신기하당 많이 써서 알아야 해요
map에는 arr.map(func)와 map(func, arr)이렇게 두가지가 있어요
오잉? 멀티스레딩이 몰락하고 함수형이 뜨고 잇다는데요 하나의 쓰레드 안에서 서로 협조하면서 하게 해라는게 인기였대요
함수를 객체처럼 다루는게 유행하기 시작한 거에요 함수형도 중요해졌다네요~
map(리스트를 함수를 통과시켜 맵을 만들어요, 결과를 리스트로 만들면 리스트로 나와요), filter(여러 원소에 동일한 함수를 먹여서 트루를 리턴하는애들만 새로 모음), reduce(모든 값을 연산해서 하나로 만드는,,? 합을 구하는..?)
잘쓰는게 중요해졌대요 map만 잘써도 됩니다ㅋㅋ
map에 전달하는 함수는 lambda를 써서 인라인 함수로 작성 가능!!! lambda x: x**2 <= 이런 식으로 쓴다는데요???














