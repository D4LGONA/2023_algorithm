힙 정렬
이진 힙: 힙 조건을 만족하는 완전 이진 트리.
 -> 트리: 그래프의 한 형태, 나무처럼 생겼어요
 -> 이진트리: 자식을 2개 이하로 가진 트리
 -> n개의 노드를 가진 힙, 완전 이진트리여서 높이가 log2n
**<루트가 0번 인덱스일때>**
 -> n의 parent를 구하는 공식 : (n-1) // 2
 -> n의 left child를 구하는 공식 : 2n + 1
 -> n의 right child를 구하는 공식 : 2n + 2
 -> n이 root일때 n == 0
 -> n이 left child가 있나요 : tree size > 2n+1 같은것까지 없음 등호 절대 안됨!!
<루트가 1번 인덱스일때>
 -> n의 parent를 구하는 공식 : n // 2
 -> n의 left child를 구하는 공식 : 2n
 -> n의 right child를 구하는 공식 : 2n + 1
 -> n이 root인가요 n == 1
 -> n이 left child가 있나요 : tree size >= 2n 얘는 등호가 반드시 필요
# 부모자식 계산하는 문제가 나온다는데요 ???
트리를 배열에 저장하는 방법
힙 조건: 각 노드의 우선순위가 자식 노드의 우선순위보다 높다
 -> 우선순위는 가장 작거나 가장 크게
최대 힙: 가장 큰 값이 루트에 저장
최소 힙: 가장 작은 값이 루트에 저장
정렬하기 위해서 힙 상태로 만드는 것

힙 정렬: 
정렬할 입력으로 최대 힙을 만든다.
힙 루트에 가장 큰 수가 있으므로, 루트와 힙의 가장 마지막 노드를 교환한다.
(가장 큰 수를 배열의 맨 뒤로 옮긴 것)
힙 크기를 1개 줄인다.
루트에 새로 저장된 숫자로 인해 위배된 힙 조건을 해결하여 힙 조건을 만족시킨다.
이 과정 반복 !!

DownHeap()
루트로부터 자식들 중에서 큰 값을 가진 자식과 비교하여 힙 속성이 만족될 때까지 숫자를 교환하며 이파리 방향으로 진행
자식이 없으면 힙 상태라고 할 수 있음
완전이진트리 -> 항상 절반은 자식이 있고 절반은 자식이 없음, 따라서 다운 힙 과정은 절반 전부터 하면 됨.
요기서 절반은 n/2 - 1
child 두개랑 비교, 큰 놈이랑 나랑 바꿈. 내가 내려가면 내려갈 수 있는 데까지 내려가야 함
# 다운힙이 어떤 과정으로 진행되는지 묻는 문제 나옴
# 뭐랑 뭘 비교하고 뭐랑 뭐가 바뀌는가?
# 끝단 처리 중요 !!

힙정렬해서 맨 끝이랑 루트랑 바꾸고 다시 다운힙(양쪽 차일드 다 힙구조여서 다운힙 가능)
하고 나면 배열 길이를 하나 줄여요 그리고 맨 뒤에 있는 친구는 더이상 힙에 참여하지 않아요

시간복잡도 다운힙 O(logn) * 힙 만드는데 O(n) = O(nlogn)

특성: 최선, 최악, 평균 모두 O(nlogn) 
큰 입력에 대해 다운힙을 수행할 때 자식을 찾아야 하므로 너무 많은 캐시 미스로 인해 페이지 부재를 야기시킴
 -> 캐시의 이점을 살릴 수 없음

셸소트랑 힙소트랑 초반엔 셸소트가빠른데 뒤로가면 힙소트가 빨라짐

정렬 문제의 하한? : nlogn이라네요... nlogn보다 빠른 정렬 알고리즘은 없음
> 비교정렬 only
 - 버블정렬, 선택정렬, 삽입정렬, 쉘정렬, 힙정렬, 합벼ㅇ졍렬, 퀵정렬의 공통점은 비교가 부분적이 아닌 숫자 대 숫자로 이루어진다
> 기수정렬은 비교정렬이 아님, 숫자들을 한자리씩 부분적ㅇ로 비교
최댓값 찾는 문제의 하한 - n-1번의 비교가 반드시 필요함
결정트리? 이건 또 뭐임

기수정렬

count sort? 
개수를 다라락 세서
count를 인덱스로 바꾼다? 앞에 녀석이랑 더해서?
앞의 녀석부터 자기 전까지
뒤에서부터 거꾸로 한대요 아하 안정리된 배열에서 정리된 배열에 옮길때 뒤부터 한단 거구나
r개의 종류가 ㅣㅇㅆ을때 n+r만큼의 시간이 걸리는 겁니다 r <<<n일때 좋음
성능측정 on 오호호 종류가 적으니까 겁나 빠르군 0.1초야 50만 개에
1억 개 하면 27초야